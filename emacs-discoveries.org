** productivity enhancements needed
- org table select a column
- replace within selected region, using multi-cursor and either doing bulk or with confirmation per potential site
- context = taxprep. in org table, a derived column is calculated from sum of space-separated numeric values in prev column. the prev column represents interest earned per quarter
** emacs configurations and elisp samples from web
;; *** recommended/stumbled packages to investigate and evaluate
;; see https://tecosaur.github.io/emacs-config/config.html for another great org rendering beautification
;; see https://emacs282.rssing.com/chan-74251933/latest-article1-live.php for ligatures rendering in source code 
;; Sacha Chua uses ox-11ty.el (https://github.com/sachac/ox-11ty) to create static web pages from orgmode sources
;; See https://github.crookster.org/switching-to-straight.el-from-emacs-26-builtin-package.el/ about removing :defer and :after and instead use :requires
;; see https://zzamboni.org/post/my-emacs-configuration-with-commentary for customization of orgmode
;; investigate : https://github.com/jerrypnz/major-mode-hydra.el (major mode hydra and pretty hydra)
;; see https://www.reddit.com/r/emacs/comments/cghg2e/autogenerated_elisp_abbrevs/ for managing abbrevs
;; see https://github.com/abo-abo/hydra/wiki/Hydra-Colors for strategies about hydra color
;; see https://github.com/kaushalmodi/.emacs.d/blob/master/setup-files/setup-outshine.el for outshine setup
;; see https://www.gnu.org/software/recutils/ - GNU Recutils is a set of tools and libraries to access human-editable, plain text databases called recfiles. The data is stored as a sequence of records, each record containing an arbitrary number of named fields. and https://www.gnu.org/software/recutils/rec-mode-manual/rec-mode.html
;; see https://kakoune-editor.github.io/community-articles/2021/01/01/first_two_hours_in_two_minutes.html
;; https://github.com/jmorag/kakoune.el for kakoune emulation in emacs
;; https://www.wisdomandwonder.com/archive - articles about emacs
;; https://glebec.github.io/lambda-talk/ - wonderful presentation about basic lambda calculus with detail speaker notes
;; look into https://github.com/wurosh/compdef for a more efficient and performant completion-at-point system (capf)
;; see also https://github.com/wurosh/handle : handle provides generic functions that specialize on major modes to do common/generic things such as 
    evaluating expressions
    starting repls
    finding documentation
    going to definition
    formatting code
    compiling code
    listing errors
;; https://emacsconf.org/2020/talks/
** Emacs keybinding conventions
- Don’t define C-c letter as a key in Lisp programs. Sequences consisting of C-c and a letter (either upper or lower case) are reserved for users; they are the only sequences reserved for users, so do not block them.
- Changing all the Emacs major modes to respect this convention was a lot of work; abandoning this convention would make that work go to waste, and inconvenience users. Please comply with it.
- Function keys F5 through F9 without modifier keys are also reserved for users to define.
- Sequences consisting of C-c followed by a control character or a digit are reserved for major modes.
- Sequences consisting of C-c followed by {, }, <, >, : or ; are also reserved for major modes.
- Sequences consisting of C-c followed by any other ASCII punctuation or symbol character are allocated for minor modes. Using them in a major mode is not absolutely prohibited, but if you do that, the major mode binding may be shadowed from time to time by minor modes.
- Don’t bind C-h following any prefix character (including C-c). If you don’t bind C-h, it is automatically available as a help character for listing the subcommands of the prefix character. 
*** Top level single key bindings with M and C modifiers
**** Elisp mode
| M-a | backward-sentence              | C-a     | lispy-move-beginning-of-line   |
| M-b | backward-word                  | C-b     | backward-char                  |
| M-c | capitalize-word                | C-c     | keymap: ctl-c                  |
| M-d | lispy-kill-word                | C-d     | lispy-delete                   |
| M-e | forward-sentence               | C-e     | lispy-move-end-of-line         |
| M-f | forward-word                   | C-f     | forward-char                   |
| M-g | ryo-modal-mode                 | C-g     | keyboard-quit                  |
| M-h | mark-paragraph                 | C-h     | help-command                   |
| M-i | lispy-iedit                    | TAB     | outshine-kbd-TAB               |
| M-j | lispy-split                    | C-j     | lispy-newline-and-indent       |
| M-k | lispy-kill-sentence            | C-k     | lispy-kill                     |
| M-l | downcase-word                  | C-l     | recenter-top-bottom            |
| M-m | lispy-mark-symbol              | C-m/RET | lispy-newline-and-indent-plain |
| M-n | undefined                      | C-n     | next-line                      |
| M-o | lispy-left-maybe               | C-o     | open-line                      |
| M-p | undefined                      | C-p     | previous-line                  |
| M-q | lispy-fill                     | C-q     | quoted-insert                  |
| M-r | move-to-window-line-top-bottom | C-r     | isearch-backward               |
| M-s | keymap: search-map             | C-s     | isearch-forward                |
| M-t | transpose-words                | C-t     | transpose-chars                |
| M-u | upcase-word                    | C-u     | universal-argument             |
| M-v | scroll-down-command            | C-v     | scroll-up-command              |
| M-w | kill-ring-save                 | C-w     | kill-region                    |
| M-x | execute-extended-command       | C-x     | keymap: ctl-x                  |
| M-y | popup-kill-ring                | C-y     | lispy-yank                     |
| M-z | zap-to-char                    | C-z     | suspend-frame                  |
** Whitespace management
- Esc-Spc : collapse WS around point
- C-x C-o : collapse consecutive white lines (delete-blank-lines)

** Elisp evaluation notation (from Info manual)
- (sexp) ⇒ something means SEXP evaluates to SOMETHING
- (third '(a b c))
          ↦ (car (cdr (cdr '(a b c))))
          ⇒ c  means macro THIRD expands to the car SEXP which evaluates to c
- (make-sparse-keymap) ≡ (list 'keymap) means the two forms are equivalent

** Elisp print notation
(progn (prin1 'foo) (princ "\n") (prin1 'bar))
          ⊣ foo
          ⊣ bar
          ⇒ bar
⊣ shows what is printed, ⇒ indicates return values

** Elisp printed representation vs read syntax
printed representation of an object is the printed output generated by prin1 function.
read syntax is the format accepted by lisp reader to convert input byte stream into lisp object.
Often, printed representation is same as read syntax.
Some objects have no read syntax (eg buffers, frames etc.). They are indicated by '#<blah>' notation.

In LISP, an expression is a lisp object (built out of cons cells). The reader converts the textual representation to an 'expression', only after which it can be 'evaluated'. Reading returns the
Lisp object represented by the text that is read; the object may or may
not be evaluated later.

For understandinc the meaning of various special objects printed with hash notation, see '2.2 Special Read Syntax' in elisp info manual

** Elisp types
See '2.4 Programming Types' for details.
- Sequence types are lists or arrays. A cons cell has two parts CAR and CDR. Each can hold any lisp object. Lists are formed by
filling car slots with objects and using cdr slot to point to next cons cell - thus each cons cell holds one element of the list.
- Dotted pair (A . B) represents one cons cell where car is reference to object A and cdr is reference to object B. A dotted pair is thus more general than list
- Association list (alist) is a list of dotted pairs. In each element, the car is considered key and cdr is considered 'associated value'.
- Arrays can be one of four types: strings, vectors, bool-vectors and char-tables
- Function type: function is a lisp object. all functions are inherently anonymous. In non-compiled form, functions have an sexp form having 'lambda' as the first symbol. A function gets a name when it is attached to the 'function slot' of a symbol.
- Macro type: it is a lisp object having the form of a sexp with first element as the symbol 'macro'. The arguments are passed as is (without evaluation) at compile time and get expanded recursively before evaluation.

** Elisp : changing generalized variables
The setf macro is the most basic way to operate on generalized variables. The setf form is like setq, except that it accepts arbitrary place forms on the left side rather than just symbols. For example, (setf (car a) b) sets the car of a to b, doing the same operation as (setcar a b), but without you having to use two separate functions for setting and accessing this type of place
For more info see: Elisp->Variables->Generalized Variables->Setting Generalized Variables
The setf macro source file has code to handle all the supported PLACE forms (generalizing the concept of l-value)
** Symbol
symbol evaluation returns it's 'value cell'

(symbol-function 'sym) returns the 'function cell' of the symbol
try: (symbol-function 'outshine-mode) - it will indicate that it is a compiled function (byte-compiled during installation of the package)
(symbol-function 'use-package) - it will indicate that it is a conscell with car='macro' and 'cdr'=compiled function (tbd)
    
** knowledge nuggets
- ~(substitute-command-keys "\\{goto-map}")~ is a way to view human-friendly keybindings in a keymap
- to encapsulate a region in 'paired symbols' (quotes, brackets etc.) select the region and self-insert the symbol
- use C-= to select regions intuitively (almost like dwim)
- use C-h B to use completion filtering to view a key binding
- C-h m describes the mode and also indicates shadowed key bindings
- If you want all self-insert keys in ryo-modal-mode to be suppressed then run command ~(suppress-keymap ryo-modal-mode-map)~ which in turn does essentially the following: ~(define-key ryo-modal-mode-map [remap self-insert-command] 'undefined)~. Notice how all ~self-insert-command~ is remapped to ~undefined~
** How to modify buffer local variables or call functions for a buffer from lisp code in scratch buffer
- use ~(with-current-buffer "buffer-name" body-forms)~
- so we can do  ~(with-current-buffer "buffer-name" (revert-buffer nil t))~
- or   ~(with-current-buffer "buffer-name" (setq varible blah))~

** How to enumerate a list or assoclist or plist or hash using dash
- ~(let (l) (--each-indexed minor-mode-map-alist (push (list (car it) it-index) l)) l)~
- see example in ~home/emacs-profiles/my-emacs/straight/repos/dash.el/dev/examples.el~
** How to manipulate minor-mode-map-alist to reorder modes
https://stackoverflow.com/questions/683425/globally-override-key-binding-in-emacs/5340797#5340797
** Emacs regex syntax
- often I see regex specified as '\\(?:blah\\)'. The '?:' means a shy group - i.e. a group that cannot be back reference by a '\digit'.
- ~'(rx stringarg)~ is a way to generate regex syntax complaint string using a mini-language which has sexp syntax with certain easy-to-read opeartors such as 'or', 'and' and other constructs. See function description through 'ctl-h f'
** Cursor (aka point) motion
- You can run the command ‘move-to-column’ with M-g TAB
- M-g actually has more useful bindings: c: goto char, l: goto line, n: next-error, p: prev-error
** Undo-tree
- C-/ : undo-tree-undo
- C-? : undo-tree-redo
- C-x r u : undo-tree-save-state-to-register
- C-x r U : undo-tree-restore-state-from-register
** Input methods
We can change input method by C-x <RET> C-\ METHOD <RET>. There are four different devnagri input methods.
** C-. triggers embark-act (embark action)
** Syntax elements in content
- char, word, sentence, sexp
- line, paragraph, function, comment, page
- back to indentation (M-m)
- goto-line : char, line, error and friends
- 
